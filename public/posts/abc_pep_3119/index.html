<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PEP 3119 ABC 번역 | tempkdw blog</title>
<meta name=keywords content="python,pep,translation"><meta name=description content="한국어 번역"><meta name=author content="Dongwook Kim"><link rel=canonical href=https://tempkdw.github.io/posts/abc_pep_3119/><meta name=google-site-verification content="8Kcuon4ueVg1494IBRKbMpaBPHtzLZKtFb_irjQvsQc"><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://tempkdw.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tempkdw.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tempkdw.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tempkdw.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tempkdw.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tempkdw.github.io/posts/abc_pep_3119/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-VKQN6XP370"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VKQN6XP370")}</script><meta property="og:url" content="https://tempkdw.github.io/posts/abc_pep_3119/"><meta property="og:site_name" content="tempkdw blog"><meta property="og:title" content="PEP 3119 ABC 번역"><meta property="og:description" content="한국어 번역"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-23T14:15:00+09:00"><meta property="article:modified_time" content="2022-09-23T14:15:00+09:00"><meta property="article:tag" content="Python"><meta property="article:tag" content="Pep"><meta property="article:tag" content="Translation"><meta property="og:image" content="https://tempkdw.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tempkdw.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="PEP 3119 ABC 번역"><meta name=twitter:description content="한국어 번역"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tempkdw.github.io/posts/"},{"@type":"ListItem","position":2,"name":"PEP 3119 ABC 번역","item":"https://tempkdw.github.io/posts/abc_pep_3119/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PEP 3119 ABC 번역","name":"PEP 3119 ABC 번역","description":"한국어 번역","keywords":["python","pep","translation"],"articleBody":"PEP 3119 – Introducing Abstract Base Classes original link\n이론적 해석 객체 지향 프로그래밍에서, 객체와 상호작용하는 사용 패턴은 두가지 기본 분류로 나눌 수 있다. 하나는 ‘호출(invocation)’ 이고 다른 하나는 ‘분석(inspection)’ 이다.\n호출은 객체의 메소드를 호출하는 것을 의미한다. 대개 다형성과 결합되어 메소드를 호출하면 어떤 타입의 객체이냐에 따라 다른 코드를 실행하게 된다.\nclass A: def foo(self): print(\"A\") class B(A): def foo(self): print(\"B\") A().foo() B().foo() 분석은 외부 코드(해당 객체의 메소드 밖의)에서 해당 객체의 타입이나 프로퍼티를 확인하고 확인한 정보에 따라 어떻게 객체를 다룰지 결정하는 것을 의미한다.\ndef foo(obj): if isinstance(obj, A): print(\"A\") elif isinstance(obj, B): print(\"B\") 두가지 사용 패턴은 동일한 결과를 보여주는데, 다양한 처리를 지원할 수 있는 것과 잠재적으로 새로운 객체들을 통일된 방법으로 지원하는 것이다. 또 동시에 각기 다른 타입의 객체를 커스텀할 수 있도록 허용 한다.\n고전적인 OOP 이론에서는, 호출이 좀더 자주 쓰이는 사용 패턴이고, 분석은 절차 지향 프로그래밍 스타일의 유산 정도로 생각되어 자주 쓰이지 않는다. 그러나 실제로는 이런 시각은 너무 경직되어있고 독단적이며, 파이썬 같은 동적 특성을 지닌 언어에서는 매우 다른 일종의 설계 경직성으로 이어진다.\n특히, 객체 클래스의 제작자가 예상하지 못한 방법으로 객체를 다뤄야하는 일이 자주 발생한다. 객체가 모든 유저의 요구에 만족하도록 모든 객체를 구성하는것은 항상 최고의 해결방법은 아니다. 게다가, 행동이 엄격하게 객체 내에 캡슐화되어야 하는 고전적인 OOP 와는 대조적인 여러가지 강력한 분배 철학들이 있다. 예를 들어 규칙 혹은 패턴 매칭 주도 로직이다.\ntype document = Text | Drawing | Spreadsheet fun draw (Text) = (* draw text doc... *) | draw (Drawing) = (* draw drawing doc... *) | draw (Spreadsheet) = (* draw spreadsheet... *) fun load (Text) = (* load text doc... *) | load (Drawing) = (* load drawing doc... *) | load (Spreadsheet) = (* load spreadsheet... *) fun save (Text) = (* save text doc... *) | save (Drawing) = (* save drawing doc... *) | save (Spreadsheet) = (* save spreadsheet... *) oop - How does pattern-match driven logic look like in real world applications? - Stack Overflow\n반면, 고전적인 OOP 이론학자들의 분석의 비난점 중 하나는 형식주의의 부족과 분석 대상의 ad hoc 특성이다. 객체의 거의 모든 면을 리플렉트 가능하고 외부 코드로 직접 접근이 가능한 Python 같은 언어에서는, 객체가 특정 프로토콜을 따르는지 아닌지를 확인할 수 있는 여러가지 다른 방법들이 있다. 예를 들어 만약 ‘이 객체는 뮤터플 시퀸스 컨테이너인가?’ 라고 했을때, 해당 객체가 list 를 상속받는지 본다던가, ‘getitem’ 이름의 메소드를 가지고 있다던가. 하지만 이런 테스트들이 명확해보임에도 불구하고 전자는 거짓 음성, 후자는 거짓 양성이므로 둘다 틀리다.\ndef is_mutable_sequence_container(obj): return True if isinstance(obj, list) else False from collections import deque is_mutable_sequence_container(deque()) # 거짓 음성 def is_mutable_sequence_container(obj): return True if hasattr(obj, '__getitem__') else False is_mutable_sequence_container(tuple()) # 거짓 양성 일반적으로 합의된 해결법은 테스트들을 표준화하고 공인된 방법으로 묶어서 정렬하는 것이다. 이것은 상속이나 다른 방법을 통해 각 클래스와 테스트 가능한 표준 프로퍼티 집합을 연결함으로써 쉽게 가능하다. 각 테스트는 일련의 약속들을 가지는데, 클래스의 일반적인 동작과 다른 클래스 메소드들로 사용가능하다는 것을 포함한다.\nclass A: def foo(self): pass class B: def foo(self): pass # TEST: A, B가 동일한 foo 메소드를 가지는가? # TEST: A, B 가 클래스인가? 이 PEP 는 Abstract Base Classes 또는 ABC 로 알려진 테스트들을 구성하는 특정 전략을 제안한다. ABC 는 객체의 특정 기능을 외부 검사자에게 알려주기 위해 객체의 상속 트리에 추가되는 간단한 Python 클래스이다. 테스트는 isinstance() 를 써서 가능하며 특정 ABC의 존재는 테스트가 통과했다는 것을 의미한다.\n이에 더해, ABC 는 특정 동작을 설정하는 최소한의 메소드 집합을 정의한다. ABC 타입을 기반으로 하는 객체를 구별하는 코드는 이런 메소드들이 항상 존재한다고 신뢰할 수 있다. 이런 각각의 메소드들은 ABC 문서에 설명된 일반화된 추상 시멘틱 정의를 가진다. 이 표준 시멘틱 정의는 강제되는 것은 아니지만 강력히 권장된다.\nclass A(ABC): @abstractmethod def foo(self): pass @abstractmethod def bar(self): pass # 최소한의 메소드집합 (foo, bar) 파이썬의 모든 다른 것들처럼, 이러한 규약은 강제되지 않은 합의인만큼, 언어가 ABC 로 만들어진 일부 규약을 시행하지만 나머지는 클래스의 구현자에게 달려있음을 의미한다.\n","wordCount":"603","inLanguage":"en","image":"https://tempkdw.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2022-09-23T14:15:00+09:00","dateModified":"2022-09-23T14:15:00+09:00","author":{"@type":"Person","name":"Dongwook Kim"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tempkdw.github.io/posts/abc_pep_3119/"},"publisher":{"@type":"Organization","name":"tempkdw blog","logo":{"@type":"ImageObject","url":"https://tempkdw.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tempkdw.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tempkdw.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tempkdw.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://tempkdw.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">PEP 3119 ABC 번역</h1><div class=post-description>한국어 번역</div><div class=post-meta><span title='2022-09-23 14:15:00 +0900 KST'>September 23, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Dongwook Kim</div></header><div class=post-content><h1 id=pep-3119--introducing-abstract-base-classes><em>PEP 3119 – Introducing Abstract Base Classes</em><a hidden class=anchor aria-hidden=true href=#pep-3119--introducing-abstract-base-classes>#</a></h1><p><a href=https://peps.python.org/pep-3119/>original link</a></p><h2 id=이론적-해석>이론적 해석<a hidden class=anchor aria-hidden=true href=#이론적-해석>#</a></h2><p>객체 지향 프로그래밍에서, 객체와 상호작용하는 사용 패턴은 두가지 기본 분류로 나눌 수 있다. 하나는 ‘호출(invocation)’ 이고 다른 하나는 ‘분석(inspection)’ 이다.</p><p>호출은 객체의 메소드를 호출하는 것을 의미한다. 대개 다형성과 결합되어 메소드를 호출하면 어떤 타입의 객체이냐에 따라 다른 코드를 실행하게 된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(self):
</span></span><span style=display:flex><span>         print(<span style=color:#e6db74>&#34;A&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span>(A):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(self):
</span></span><span style=display:flex><span>         print(<span style=color:#e6db74>&#34;B&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A()<span style=color:#f92672>.</span>foo()
</span></span><span style=display:flex><span>B()<span style=color:#f92672>.</span>foo()
</span></span></code></pre></div><p>분석은 외부 코드(해당 객체의 메소드 밖의)에서 해당 객체의 타입이나 프로퍼티를 확인하고 확인한 정보에 따라 어떻게 객체를 다룰지 결정하는
것을 의미한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(obj):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> isinstance(obj, A):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;A&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> isinstance(obj, B):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;B&#34;</span>)
</span></span></code></pre></div><p>두가지 사용 패턴은 동일한 결과를 보여주는데, 다양한 처리를 지원할 수 있는 것과 잠재적으로 새로운 객체들을 통일된 방법으로 지원하는 것이다. 또 동시에 각기 다른 타입의 객체를 커스텀할 수 있도록 허용 한다.</p><p>고전적인 OOP 이론에서는, 호출이 좀더 자주 쓰이는 사용 패턴이고, 분석은 절차 지향 프로그래밍 스타일의 유산 정도로 생각되어 자주 쓰이지 않는다. 그러나 실제로는 이런 시각은 너무 경직되어있고 독단적이며, 파이썬 같은 동적 특성을 지닌 언어에서는 매우 다른 일종의 설계 경직성으로 이어진다.</p><p>특히, 객체 클래스의 제작자가 예상하지 못한 방법으로 객체를 다뤄야하는 일이 자주 발생한다. 객체가 모든 유저의 요구에 만족하도록 모든 객체를 구성하는것은 항상 최고의 해결방법은 아니다. 게다가, 행동이 엄격하게 객체 내에 캡슐화되어야 하는 고전적인 OOP 와는 대조적인 여러가지 강력한 분배 철학들이 있다. 예를 들어 규칙 혹은 패턴 매칭 주도 로직이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> document
</span></span><span style=display:flex><span>  <span style=color:#f92672>=</span> <span style=color:#a6e22e>Text</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Drawing</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Spreadsheet</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> draw <span style=color:#f92672>(</span><span style=color:#a6e22e>Text</span><span style=color:#f92672>)</span>        <span style=color:#f92672>=</span> <span style=color:#75715e>(* draw text doc... *)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> draw <span style=color:#f92672>(</span><span style=color:#a6e22e>Drawing</span><span style=color:#f92672>)</span>     <span style=color:#f92672>=</span> <span style=color:#75715e>(* draw drawing doc... *)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> draw <span style=color:#f92672>(</span><span style=color:#a6e22e>Spreadsheet</span><span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#75715e>(* draw spreadsheet... *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> load <span style=color:#f92672>(</span><span style=color:#a6e22e>Text</span><span style=color:#f92672>)</span>        <span style=color:#f92672>=</span> <span style=color:#75715e>(* load text doc... *)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> load <span style=color:#f92672>(</span><span style=color:#a6e22e>Drawing</span><span style=color:#f92672>)</span>     <span style=color:#f92672>=</span> <span style=color:#75715e>(* load drawing doc... *)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> load <span style=color:#f92672>(</span><span style=color:#a6e22e>Spreadsheet</span><span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#75715e>(* load spreadsheet... *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> save <span style=color:#f92672>(</span><span style=color:#a6e22e>Text</span><span style=color:#f92672>)</span>        <span style=color:#f92672>=</span> <span style=color:#75715e>(* save text doc... *)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> save <span style=color:#f92672>(</span><span style=color:#a6e22e>Drawing</span><span style=color:#f92672>)</span>     <span style=color:#f92672>=</span> <span style=color:#75715e>(* save drawing doc... *)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> save <span style=color:#f92672>(</span><span style=color:#a6e22e>Spreadsheet</span><span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#75715e>(* save spreadsheet... *)</span>
</span></span></code></pre></div><p><a href=https://stackoverflow.com/questions/30937538/how-does-pattern-match-driven-logic-look-like-in-real-world-applications>oop - How does pattern-match driven logic look like in real world applications? - Stack Overflow</a></p><p>반면, 고전적인 OOP 이론학자들의 분석의 비난점 중 하나는 형식주의의 부족과 분석 대상의 ad hoc 특성이다. 객체의 거의 모든 면을 리플렉트 가능하고 외부 코드로 직접 접근이 가능한 Python 같은 언어에서는, 객체가 특정 프로토콜을 따르는지 아닌지를 확인할 수 있는 여러가지 다른 방법들이 있다. 예를 들어 만약 ‘이 객체는 뮤터플 시퀸스 컨테이너인가?’ 라고 했을때, 해당 객체가 list 를 상속받는지 본다던가, ‘<strong>getitem</strong>’ 이름의 메소드를 가지고 있다던가. 하지만 이런 테스트들이 명확해보임에도 불구하고 전자는 거짓 음성, 후자는 거짓 양성이므로 둘다 틀리다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_mutable_sequence_container</span>(obj):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span> <span style=color:#66d9ef>if</span> isinstance(obj, list) <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> deque
</span></span><span style=display:flex><span>is_mutable_sequence_container(deque())  <span style=color:#75715e># 거짓 음성</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_mutable_sequence_container</span>(obj):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span> <span style=color:#66d9ef>if</span> hasattr(obj, <span style=color:#e6db74>&#39;__getitem__&#39;</span>) <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>is_mutable_sequence_container(tuple())  <span style=color:#75715e># 거짓 양성</span>
</span></span></code></pre></div><p>일반적으로 합의된 해결법은 테스트들을 표준화하고 공인된 방법으로 묶어서 정렬하는 것이다. 이것은 상속이나 다른 방법을 통해 각 클래스와 테스트 가능한 표준 프로퍼티 집합을 연결함으로써 쉽게 가능하다. 각 테스트는 일련의 약속들을 가지는데, 클래스의 일반적인 동작과 다른 클래스 메소드들로 사용가능하다는 것을 포함한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(self): <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(self): <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># TEST: A, B가 동일한 foo 메소드를 가지는가?</span>
</span></span><span style=display:flex><span><span style=color:#75715e># TEST: A, B 가 클래스인가?</span>
</span></span></code></pre></div><p>이 PEP 는 Abstract Base Classes 또는 ABC 로 알려진 테스트들을 구성하는 특정 전략을 제안한다. ABC 는 객체의 특정 기능을 외부 검사자에게 알려주기 위해 객체의 상속 트리에 추가되는 간단한 Python 클래스이다. 테스트는 <code>isinstance()</code> 를 써서 가능하며 특정 ABC의 존재는 테스트가 통과했다는 것을 의미한다.</p><p>이에 더해, ABC 는 특정 동작을 설정하는 최소한의 메소드 집합을 정의한다. ABC 타입을 기반으로 하는 객체를 구별하는 코드는 이런 메소드들이 항상 존재한다고 신뢰할 수 있다. 이런 각각의 메소드들은 ABC 문서에 설명된 일반화된 추상 시멘틱 정의를 가진다. 이 표준 시멘틱 정의는 강제되는 것은 아니지만 강력히 권장된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>(ABC):
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@abstractmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(self): <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@abstractmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bar</span>(self): <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 최소한의 메소드집합 (foo, bar)</span>
</span></span></code></pre></div><p>파이썬의 모든 다른 것들처럼, 이러한 규약은 강제되지 않은 합의인만큼, 언어가 ABC 로 만들어진 일부 규약을 시행하지만 나머지는 클래스의 구현자에게 달려있음을 의미한다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tempkdw.github.io/tags/python/>Python</a></li><li><a href=https://tempkdw.github.io/tags/pep/>Pep</a></li><li><a href=https://tempkdw.github.io/tags/translation/>Translation</a></li></ul><nav class=paginav><a class=prev href=https://tempkdw.github.io/posts/cpython-debug/><span class=title>« Prev</span><br><span>Python 내부의 C 코드 들여다보기</span>
</a><a class=next href=https://tempkdw.github.io/posts/circular_import/><span class=title>Next »</span><br><span>Circular import에 대한 생각</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share PEP 3119 ABC 번역 on x" href="https://x.com/intent/tweet/?text=PEP%203119%20ABC%20%eb%b2%88%ec%97%ad&amp;url=https%3a%2f%2ftempkdw.github.io%2fposts%2fabc_pep_3119%2f&amp;hashtags=python%2cpep%2ctranslation"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share PEP 3119 ABC 번역 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ftempkdw.github.io%2fposts%2fabc_pep_3119%2f&amp;title=PEP%203119%20ABC%20%eb%b2%88%ec%97%ad&amp;summary=PEP%203119%20ABC%20%eb%b2%88%ec%97%ad&amp;source=https%3a%2f%2ftempkdw.github.io%2fposts%2fabc_pep_3119%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share PEP 3119 ABC 번역 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2ftempkdw.github.io%2fposts%2fabc_pep_3119%2f&title=PEP%203119%20ABC%20%eb%b2%88%ec%97%ad"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share PEP 3119 ABC 번역 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftempkdw.github.io%2fposts%2fabc_pep_3119%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share PEP 3119 ABC 번역 on whatsapp" href="https://api.whatsapp.com/send?text=PEP%203119%20ABC%20%eb%b2%88%ec%97%ad%20-%20https%3a%2f%2ftempkdw.github.io%2fposts%2fabc_pep_3119%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share PEP 3119 ABC 번역 on telegram" href="https://telegram.me/share/url?text=PEP%203119%20ABC%20%eb%b2%88%ec%97%ad&amp;url=https%3a%2f%2ftempkdw.github.io%2fposts%2fabc_pep_3119%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share PEP 3119 ABC 번역 on ycombinator" href="https://news.ycombinator.com/submitlink?t=PEP%203119%20ABC%20%eb%b2%88%ec%97%ad&u=https%3a%2f%2ftempkdw.github.io%2fposts%2fabc_pep_3119%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tempkdw.github.io/>tempkdw blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>